!function() {
    "use strict";
    class e {
        constructor(e, t) {
            this.xs = e,
            this.ys = t,
            this.ks = this.getNaturalKs(new Float64Array(this.xs.length))
        }
        getNaturalKs(e) {
            const n = this.xs.length - 1
              , s = function(e, t) {
                const n = [];
                for (let s = 0; s < e; s++)
                    n.push(new Float64Array(t));
                return n
            }(n + 1, n + 2);
            for (let e = 1; e < n; e++)
                s[e][e - 1] = 1 / (this.xs[e] - this.xs[e - 1]),
                s[e][e] = 2 * (1 / (this.xs[e] - this.xs[e - 1]) + 1 / (this.xs[e + 1] - this.xs[e])),
                s[e][e + 1] = 1 / (this.xs[e + 1] - this.xs[e]),
                s[e][n + 1] = 3 * ((this.ys[e] - this.ys[e - 1]) / ((this.xs[e] - this.xs[e - 1]) * (this.xs[e] - this.xs[e - 1])) + (this.ys[e + 1] - this.ys[e]) / ((this.xs[e + 1] - this.xs[e]) * (this.xs[e + 1] - this.xs[e])));
            return s[0][0] = 2 / (this.xs[1] - this.xs[0]),
            s[0][1] = 1 / (this.xs[1] - this.xs[0]),
            s[0][n + 1] = 3 * (this.ys[1] - this.ys[0]) / ((this.xs[1] - this.xs[0]) * (this.xs[1] - this.xs[0])),
            s[n][n - 1] = 1 / (this.xs[n] - this.xs[n - 1]),
            s[n][n] = 2 / (this.xs[n] - this.xs[n - 1]),
            s[n][n + 1] = 3 * (this.ys[n] - this.ys[n - 1]) / ((this.xs[n] - this.xs[n - 1]) * (this.xs[n] - this.xs[n - 1])),
            function(e, n) {
                const s = e.length;
                let r = 0
                  , o = 0;
                for (; r < s && o <= s; ) {
                    let n = 0
                      , i = -1 / 0;
                    for (let t = r; t < s; t++) {
                        const s = Math.abs(e[t][o]);
                        s > i && (n = t,
                        i = s)
                    }
                    if (0 === e[n][o])
                        o++;
                    else {
                        t(e, r, n);
                        for (let t = r + 1; t < s; t++) {
                            const n = e[t][o] / e[r][o];
                            e[t][o] = 0;
                            for (let i = o + 1; i <= s; i++)
                                e[t][i] -= e[r][i] * n
                        }
                        r++,
                        o++
                    }
                }
                for (let t = s - 1; t >= 0; t--) {
                    var i = 0;
                    e[t][t] && (i = e[t][s] / e[t][t]),
                    n[t] = i;
                    for (let n = t - 1; n >= 0; n--)
                        e[n][s] -= e[n][t] * i,
                        e[n][t] = 0
                }
                return n
            }(s, e)
        }
        getIndexBefore(e) {
            let t = 0
              , n = this.xs.length
              , s = 0;
            for (; t < n; )
                s = Math.floor((t + n) / 2),
                this.xs[s] < e && s !== t ? t = s : n = this.xs[s] >= e && s !== n ? s : t;
            return t + 1
        }
        at(e) {
            let t = this.getIndexBefore(e);
            const n = (e - this.xs[t - 1]) / (this.xs[t] - this.xs[t - 1])
              , s = this.ks[t - 1] * (this.xs[t] - this.xs[t - 1]) - (this.ys[t] - this.ys[t - 1])
              , r = -this.ks[t] * (this.xs[t] - this.xs[t - 1]) + (this.ys[t] - this.ys[t - 1]);
            return (1 - n) * this.ys[t - 1] + n * this.ys[t] + n * (1 - n) * (s * (1 - n) + r * n)
        }
    }
    function t(e, t, n) {
        let s = e[t];
        e[t] = e[n],
        e[n] = s
    }
    const n = new THREE.WebGLRenderer({
        alpha: !0,
        antialias: !0
    })
      , s = new THREE.Scene
      , r = [window.innerWidth, window.innerHeight]
      , o = new THREE.PerspectiveCamera(30,r[0] / r[1])
      , i = new THREE.Color(0,60 / 255,1)
      , a = new THREE.Color(40 / 255,91 / 255,1)
      , h = new THREE.Color(0,60 / 255,1)
      , l = new THREE.MeshBasicMaterial({
        color: i,
        depthFunc: THREE.AlwaysDepth,
        transparent: !0
    })
      , E = new THREE.MeshBasicMaterial({
        color: a,
        depthFunc: THREE.AlwaysDepth,
        transparent: !0
    })
      , d = {}
      , w = {}
      , f = new THREE.Group
      , u = [0, 0]
      , c = [0, 0]
      , m = [0, 0];
    let y = !1
      , R = []
      , p = new THREE.Group
      , T = 0
      , x = 1
      , H = 0
      , A = 0
      , g = 1;
    function M(e) {
        return --e * e * e + 1
    }
    function B() {
        r[0] = window.innerWidth,
        r[1] = window.innerHeight,
        n.setSize(r[0], r[1]),
        u[0] = r[0] / r[1] * 11.8,
        u[1] = 11.8,
        o.aspect = r[0] / r[1],
        o.updateProjectionMatrix(),
        o.position.x = Math.tan((90 - o.fov / 2) * (Math.PI / 180)) * (u[1] / 2)
    }
    function b(e) {
        y = !0,
        m[0] = e.clientX / r[0] * 2 - 1,
        m[1] = e.clientY / r[1] * 2 - 1
    }
    let F = Date.now()
      , L = 0
      , k = 0;
    function z() {
        L = Date.now() - F,
        F += L,
        k = 1 - Math.pow(.02, L / 1e3),
        requestAnimationFrame(z),
        p.scale.x = p.scale.y = p.scale.z = p.scale.x * (1 - k) + 1 * k;
        for (let e = 0; e < R.length; e++)
            R[e].rotation.x += 1e-4 * R[e].speedX,
            R[e].rotation.y += .001 * R[e].speedY,
            R[e].rotation.z += 5e-4 * R[e].speedZ;
        y || (m[0] *= 1 - k,
        m[1] *= 1 - k),
        c[0] = c[0] * (1 - k) + m[0] * k,
        c[1] = c[1] * (1 - k) + m[1] * k,
        f.rotation.y = 30 * c[0] * (Math.PI / 180),
        f.rotation.z = -30 * c[1] * (Math.PI / 180),
        p.rotation.y = 16 * c[0] * (Math.PI / 180),
        p.rotation.z = -16 * c[1] * (Math.PI / 180),
        n.render(s, o)
    }
    !function() {
        let e, t = new THREE.TextureLoader, n = [];
        document.getElementById("hero") && document.getElementById("hero").getAttribute("data-sprites") && (n = document.getElementById("hero").getAttribute("data-sprites").split(",")),
        0 === n.length && (e = new THREE.PointsMaterial({
            color: i,
            size: .15,
            opacity: .8,
            transparent: !0
        }));
        let r = new THREE.Vector3;
        for (let s = 0; s < 4; s++) {
            n.length > 0 && (e = new THREE.PointsMaterial({
                color: i,
                size: .3,
                map: t.load(n[s % n.length]),
                opacity: .8,
                transparent: !0
            }),
            e.map.minFilter = THREE.LinearFilter);
            let a = new THREE.BufferGeometry
              , h = new Float32Array(600);
            for (let e = 0; e < 200; e++)
                r.setFromSphericalCoords(1 + 16 * ((o = M(Math.random())) * (2 - o)), (170 * Math.random() + 5) * (Math.PI / 180), 360 * Math.random() * (Math.PI / 180)),
                h[3 * e] = r.x,
                h[3 * e + 1] = r.y,
                h[3 * e + 2] = r.z;
            a.setAttribute("position", new THREE.BufferAttribute(h,3));
            let l = new THREE.Points(a,e);
            l.speedX = Math.random() - .5,
            l.speedY = Math.random() - .5,
            l.speedZ = Math.random() - .5,
            p.add(l),
            R.push(l),
            l.renderOrder = 0
        }
        var o;
        s.add(p),
        p.scale.x = p.scale.y = p.scale.z = 0,
        p.position.x = -2,
        p.renderOrder = 0
    }(),
    function() {
        {
            let t = new THREE.BufferGeometry;
            t.setAttribute("position", new THREE.BufferAttribute(new Float32Array([0, .49, -1, 0, .49, 1, 0, -1.875, 0]),3)),
            d.center = new THREE.Mesh(t,l),
            f.add(d.center),
            w.center = {
                start: 0,
                end: .98,
                y: new e([0, .45, 1],[2.3, 1.34, 0]),
                scale: new e([0, .45, 1],[3.5, 1.95, 1])
            }
        }
        {
            let t = new THREE.BufferGeometry;
            t.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.48, 1.07, -.45, -.48, 1.07, .45, -.03, .54, 1, -.03, .54, -1]),3)),
            t.setIndex([0, 1, 2, 0, 2, 3]),
            d.forehead = new THREE.Mesh(t,l),
            f.add(d.forehead),
            w.forehead = {
                start: .3,
                end: .98,
                y: new e([0, .7, 1],[5.3, 1.2, 0]),
                scale: new e([0, 1],[1.5, 1])
            }
        }
        {
            let t = new THREE.BufferGeometry;
            t.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.03, .475, 1.05, -.45, -.13, 1.36, -.03, -1, .425]),3));
            let n = new THREE.BufferGeometry;
            n.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.45, -.13, 1.36, -.63, -.4, 1.5, -.03, -1, .425]),3)),
            d.cheekRightTop = new THREE.Mesh(t,l),
            d.cheekRightBottom = new THREE.Mesh(n,E),
            f.add(d.cheekRightTop),
            f.add(d.cheekRightBottom),
            w.cheekRight = {
                start: .45,
                end: 1,
                z: new e([0, .45, 1],[9, 1.46, 0]),
                y: new e([0, .45, 1],[-3.48, -1.51, 0]),
                scale: new e([0, .45, 1],[2.13, 1.69, 1])
            },
            w.cheekRightTop = w.cheekRightBottom = w.cheekRight
        }
        {
            let t = new THREE.BufferGeometry;
            t.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.03, .475, -1.05, -.03, -1, -.425, -.45, -.13, -1.36]),3));
            let n = new THREE.BufferGeometry;
            n.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.45, -.13, -1.36, -.03, -1, -.425, -.63, -.4, -1.5]),3)),
            d.cheekLeftTop = new THREE.Mesh(t,l),
            d.cheekLeftBottom = new THREE.Mesh(n,E),
            f.add(d.cheekLeftTop),
            f.add(d.cheekLeftBottom),
            w.cheekLeft = {
                start: 0,
                end: .98,
                z: new e([0, .45, 1],[-3.5, -1.16, 0]),
                y: new e([0, .45, 1],[1.88, .51, 0]),
                scale: new e([0, .45, 1],[5.27, 2.38, 1])
            },
            w.cheekLeftTop = w.cheekLeftBottom = w.cheekLeft
        }
        {
            let t = new THREE.BufferGeometry;
            t.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.52, 1.09, .49, -1.2, 1.84, 1.62, -.049, .56, 1.05]),3));
            let n = new THREE.BufferGeometry;
            n.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.049, .56, 1.05, -1.2, 1.84, 1.62, -.31, .15, 1.26]),3)),
            d.earRightTop = new THREE.Mesh(t,l),
            d.earRightBottom = new THREE.Mesh(n,E),
            f.add(d.earRightTop),
            f.add(d.earRightBottom),
            w.earRight = {
                start: 0,
                end: .99,
                z: new e([0, .45, 1],[3.35, 1.5, 0]),
                y: new e([0, .45, 1],[-.5, -.1, 0]),
                scale: new e([0, .45, 1],[4.2, 2.35, 1])
            },
            w.earRightTop = w.earRightBottom = w.earRight
        }
        {
            let t = new THREE.BufferGeometry;
            t.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.525, 1.09, -.49, -.049, .56, -1.05, -1.2, 1.84, -1.62]),3));
            let n = new THREE.BufferGeometry;
            n.setAttribute("position", new THREE.BufferAttribute(new Float32Array([-.049, .56, -1.05, -.31, .15, -1.26, -1.2, 1.84, -1.62]),3)),
            d.earLeftTop = new THREE.Mesh(t,l),
            d.earLeftBottom = new THREE.Mesh(n,E),
            f.add(d.earLeftTop),
            f.add(d.earLeftBottom),
            w.earLeft = {
                start: .39,
                end: .99,
                z: new e([0, .45, 1],[-10, -2, 0]),
                y: new e([0, .45, 1],[1, .3, 0]),
                scale: new e([0, .5, 1],[4, 2.1, 1])
            },
            w.earLeftTop = w.earLeftBottom = w.earLeft
        }
        s.add(f),
        f.position.y = .05;
        for (let e = 0; e < f.children.length; e++)
            f.children[e].renderOrder = 3;
        f.renderOrder = 2
    }(),
    s.fog = new THREE.Fog(0,20,50),
    o.position.set(20, 0, 0),
    o.lookAt(0, 0, 0),
    B(),
    requestAnimationFrame(B),
    document.getElementById("hero").appendChild(n.domElement),
    window.addEventListener("resize", B),
    window.document.body.addEventListener("mousemove", b),
    window.document.body.addEventListener("touchmove", (function(e) {
        b(e.touches[0])
    }
    )),
    n.domElement.addEventListener("touchend", (function(e) {
        0 === e.touches.length && (y = !1)
    }
    )),
    n.domElement.addEventListener("mouseout", (function() {
        y = !1
    }
    )),
    requestAnimationFrame((function e() {
        var t;
        L = Date.now() - F,
        F += L,
        k = 1 - Math.pow(.02, L / 1e3),
        y || (m[0] *= 1 - k,
        m[1] *= 1 - k),
        c[0] = c[0] * (1 - k) + m[0] * k,
        c[1] = c[1] * (1 - k) + m[1] * k,
        T = Math.max(0, Math.min(100, .7 * T + .3 * (window.loadPercentage || 0))),
        x = (100 - T) / 100,
        g = M(x),
        h.g = i.g * g + a.g * (1 - g),
        h.b = i.b * g + a.b * (1 - g),
        E.color = h,
        x = (t = x) * t,
        H = T / 100;
        for (let e in d)
            w.hasOwnProperty(e) && (A = (H - w[e].start) / (w[e].end - w[e].start),
            A = Math.max(0, Math.min(1, A)),
            w[e].y && (d[e].position.y = w[e].y.at(A) / 5.6 * u[1] / 2),
            w[e].z && (d[e].position.z = w[e].z.at(A) / 7 * u[0] / 2),
            w[e].scale && (d[e].scale.x = d[e].scale.y = d[e].scale.z = 1 + 1.25 * (w[e].scale.at(A) - 1)));
        f.rotation.y = Math.max(0, 1 - 10 * x) * c[0] * 30 * (Math.PI / 180),
        f.rotation.z = Math.max(0, 1 - 10 * x) * c[1] * -30 * (Math.PI / 180),
        n.render(s, o),
        T >= 99.99 ? (E.color = a,
        requestAnimationFrame(z)) : requestAnimationFrame(e)
    }
    ))
}();
